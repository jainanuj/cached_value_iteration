/* ftvi.c */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include "track.h"
#include "graph.h"
#include "atvi.h"
#include "backup.h"
#include "solve.h"
//#include "top.h"
#define MAX_ITER   1000
#define SIZE_THRESHOLD 1000

static void initsearch(int, int);
static void accplaning(int);
static void expandsolution(struct StateNode*);
static void buildtop();
static void solve_component(int);
static void f_reachability(int s);
void f_viter(struct StateListNode *list, int MaxIter);
static void f_dfs(int w);
static void f_dfsR(int w);
void c_dfs(int w, int round);
void c_dfsR(int w, int round);

/* global variables */
static int trial;
static int stateExpanded;
static int stateExpandedTrial;
static int scnt;
static int cnt;
static struct StateListNode **stateListNode;

static int local_cnt;
static int local_scnt;

int *id;
int *postI;
int *postR;
int *reachable;
int *reachableC;
int *sizes;

int *state_hash;
int *inv_state_hash;
int *local_id;
int *local_postI;
int *local_postR;
int *local_reachableC;
int *local_sizes;
int biggest_size = 0;
struct StateListNode **local_stateListNode;

void FTVI(int version)
{
  // number of initial trials
  int lTrials = 100, uTrials = 10000;
  initsearch(lTrials, uTrials);
  accplaning(version);
}

void initsearch(int lTrials, int uTrials)
{
  struct StateNode *state, *node;
  struct ActionNode *action;
  double diff, maxdiff, val, wavg, time;
  int i, steps;
  char c;
  struct timeval t, t1;
  
  stateExpanded = 0;
  for (i = 0; i < uTrials/lTrials; ++i) {
    wavg = Start->f;
    for (trial = 0; trial < lTrials; ++trial)
      expandsolution(Start);
    if ( wavg / Start->f > .97 ) {
      ++i;
      break;
    }
  }

  printf("\nState expanded: %d", stateExpanded);
  gettimeofday(&t, NULL);
  time = (t.tv_sec - gInitialT.tv_sec) + (float)(t.tv_usec - gInitialT.tv_usec) / 1000000;
  printf("\nInitial %d trials( %f secs.)  f: %f", i*lTrials, time, Start->f);
  buildtop();
  gettimeofday(&t1, NULL);
  time = (t1.tv_sec - t.tv_sec) + (float)(t1.tv_usec - t.tv_usec) / 1000000;
  printf("\nelapsed time for building topological structure: %f", time);
}

static void accplaning(int version)
{
  int round, i, j, steps;
  struct StateListNode *list;
  struct StateNode *state, *head;
  struct ActionNode *action;
  double diff, maxdiff, val, wavg, time, residual, avgdiff, backupnum;
  struct timeval t;

  scnt = id[gInitialState] + 1;
  for (round = 1; round < scnt; round++) {
    if (reachableC[round]) {
      int cur_size = sizes[round];
//      if (cur_size > 1000)
//        printf("\n round %d size %d", round, cur_size);
      if (version == 1) {
        if (cur_size > biggest_size)
          biggest_size = cur_size;
        list = stateListNode[round];
        f_viter(list, MAX_ITER);
      }
      else
        solve_component(round);
//      gettimeofday(&t, NULL);
//      time = (t.tv_sec - gInitialT.tv_sec) + (float)(t.tv_usec - gInitialT.tv_usec) / 1000000;
//      printf("\n%5d ( %f secs.)  f: %f", round, time, Start->f);
    }
  }
  Backup(Start);
  printf("\n Biggest component size: %d", biggest_size);
  gettimeofday(&t, NULL);
  time = (t.tv_sec - gInitialT.tv_sec) + (float)(t.tv_usec - gInitialT.tv_usec) / 1000000;
  printf("\n%d ( %f secs.)  f: %f Converged!", round, time, Start->f);
  printf("\n");
}

static void expandsolution(struct StateNode* node)
{
  struct StateDistribution *successor;

  if ( (node->Terminal == 5) || (node->Converged) )
    return;
  
  if (node->Expanded == 0) 
    BackupTwo(node);
  ++stateExpanded;
  
  /* Assume successor states are sorted in order of probability */
  for (successor = node->BestAction->NextState;
       successor;
       successor = successor->Next) {
    
    /* Stop if already visited this iteration or goal state */
    if ((successor->State->Expanded < trial) && (successor->State->Terminal != 1)) {
      /* If already expanded, just mark as visited this iteration */
      successor->State->Expanded = trial;
      expandsolution(successor->State);
    }
  }
  BackupTwo(node);
}

static void buildtop(void)
{
  int state, round;
  struct StateNode     *node;
  struct StateListNode *list, *new;
  struct ActionNode    *actionNode;
  
  id = (int*)malloc((unsigned)gNumStates * sizeof(int));
  postI = (int*)malloc((unsigned)gNumStates * sizeof(int));
  postR = (int*)malloc((unsigned)gNumStates * sizeof(int));
  reachable = (int*)malloc((unsigned)gNumStates * sizeof(int));

  for (state = 0; state < gNumStates; state++) {
    reachable[state] = 0;
  }
  f_reachability(0);
  
  cnt = 0;
  scnt = 0;
  for (state = 0; state < gNumStates; state++)
    id[state] = -1;
  for (state = 0; state < gNumStates; state++)
    if (id[state] == -1)
      f_dfsR(state);
  for (state = 0; state < gNumStates; state++)
    postR[state] = postI[state];
  
  cnt = 0;
  scnt = 0;
  for (state = 0; state < gNumStates; state++)
    id[state] = -1;
  for (state = gNumStates - 1; state >= 0; state--)
    if (id[postR[state]] == -1) {
      f_dfs(postR[state]);
      scnt++;
    }
  free(postI);
  free(postR);
      
  printf("\nComponents: %d", scnt);
  sizes = (int*)malloc(scnt * sizeof(int));
  // debugging  
  stateListNode = (struct StateListNode**)malloc(scnt * sizeof(struct StateListNode*));
  reachableC = (int*)malloc(scnt * sizeof(int));
  
  for (round = 0; round < scnt; round++) {
    stateListNode[round] = (struct StateListNode*)malloc(sizeof(struct StateListNode));
    stateListNode[round]->Node = NULL;
    stateListNode[round]->Next = NULL;
    reachableC[round] = 0;
    sizes[round] = 0;
  }
    
  for (state = 0; state < gNumStates; ++state) {
    list = stateListNode[id[state]];
    node = StateIndex[state];
    // ignore unreachable and deadend states
    if (reachable[state])
      reachableC[id[state]] = 1;
    ++sizes[id[state]];
    if (!list->Node) {
      list->Node = node;
    }
    else {
      new = (struct StateListNode*)malloc((unsigned)sizeof(struct StateListNode));
      new->Node = list->Node;
      new->Next = list->Next;
      list->Node = node;
      list->Next = new;
    }
  }
  //free(id);
  //free(reachable);
}

void f_dfs(int w)
{
  int nodeNumber;
  struct StateNode *state;
  struct StateListNode *list;
  struct ActionListNode *actionListNode;
  struct ActionNode *actionNode;
  struct StateDistribution *nextState;
   
  id[w] = scnt;
  state = StateIndex[w];

  if ( (state->Terminal == 1) || (state->Terminal == 5) )
    return;
  
  for (actionListNode = state->Action;
       actionListNode;
       actionListNode = actionListNode->Next) {
    actionNode = actionListNode->Node;
    if (actionNode->Dominated == 1)
      continue;
    for (nextState = actionNode->NextState;
	 nextState;
	 nextState = nextState->Next) {
      nodeNumber = nextState->State->StateNo;
      if (id[nodeNumber] == -1)
        f_dfs(nodeNumber);
    }
  }
  postI[cnt++] = w;
}
 
void f_dfsR(int w)
{
  int nodeNumber;
  struct StateNode *state;
  struct StateListNode *list;
  struct ActionListNode *actionListNode;
  struct ActionNode *actionNode;
  struct StateNode *prevState;
   
  id[w] = scnt;
  state = StateIndex[w];
  
  for (actionListNode = state->PrevAction;
       actionListNode;
       actionListNode = actionListNode->Next) {
    actionNode = actionListNode->Node;
    if (actionNode->Dominated == 1)
      continue;
    prevState = actionNode->PrevState;
      nodeNumber = prevState->StateNo;
      if (id[nodeNumber] == -1)
        f_dfsR(nodeNumber);
  }
  postI[cnt++] = w;
}

void f_reachability(int s)
{
  struct StateNode *state;
  struct StateListNode *list;
  struct ActionListNode *actionListNode;
  struct ActionNode *actionNode;
  struct StateDistribution *nextState;

  state = StateIndex[s];
  reachable[s] = 1;
  for (actionListNode = state->Action;
       actionListNode;
       actionListNode = actionListNode->Next) {
    actionNode = actionListNode->Node;
    if (actionNode->Dominated == 1)
      continue;
    for (nextState = actionNode->NextState;
	 nextState;
	 nextState = nextState->Next) {
      int nodeNumber = nextState->State->StateNo;
      if (reachable[nodeNumber] == 0)
        f_reachability(nodeNumber);
    }
  }
}

void search_inside_component(struct StateNode* node, int round, int trial)
{
  struct StateDistribution *successor;

  if ( (node->Terminal == 5) || (node->Converged) )
    return;
  
  if (node->Expanded == 0) 
    BackupTwo(node);
  ++stateExpanded;
  
  for (successor = node->BestAction->NextState;
       successor;
       successor = successor->Next) {
    
    // terminate search if out of the component
    if (id[successor->State->StateNo] != round)
      continue;
    /* Stop if already visited this iteration or goal state */
    if ((successor->State->Expanded < trial) && (successor->State->Terminal != 1)) {
      /* If already expanded, just mark as visited this iteration */
      successor->State->Expanded = trial;
      search_inside_component(successor->State, round, trial);
    }
  }
  BackupTwo(node);
}

void c_dfs(int w, int round)
{
  int nodeNumber;
  struct StateNode *state, *newstate;
  struct StateListNode *list;
  struct ActionListNode *actionListNode;
  struct ActionNode *actionNode;
  struct StateDistribution *nextState;
   
  local_id[w] = local_scnt;
  state = StateIndex[state_hash[w]];
  
  for (actionListNode = state->Action;
       actionListNode;
       actionListNode = actionListNode->Next) {
    actionNode = actionListNode->Node;
    if (actionNode->Dominated)
      continue;
    for (nextState = actionNode->NextState;
	 nextState;
	 nextState = nextState->Next) {
      newstate = nextState->State;
      // if out of the component, quit
      if (id[newstate->StateNo] != round)
        continue;
      nodeNumber = inv_state_hash[newstate->StateNo];
      if (local_id[nodeNumber] == -1)
        c_dfs(nodeNumber, round);
    }
  }
  local_postI[local_cnt++] = w;
}
 
void c_dfsR(int w, int round)
{
  int nodeNumber;
  struct StateNode *state;
  struct StateListNode *list;
  struct ActionListNode *actionListNode;
  struct ActionNode *actionNode;
  struct StateNode *prevState;
   
  local_id[w] = local_scnt;
  state = StateIndex[state_hash[w]];
  
  for (actionListNode = state->PrevAction;
       actionListNode;
       actionListNode = actionListNode->Next) {
    actionNode = actionListNode->Node;
    if (actionNode->Dominated)
      continue;
    prevState = actionNode->PrevState;
    // if out of the component, quit
    if (id[prevState->StateNo] != round)
      continue;
    nodeNumber = inv_state_hash[prevState->StateNo];
    if (local_id[nodeNumber] == -1)
      c_dfsR(nodeNumber, round);
  }
  local_postI[local_cnt++] = w;
}

void solve_component(int round)
{
  int local_round;
  int size = sizes[round];
  struct StateNode *node, *stateNode;
  struct StateListNode *list, *local_list, *new_list;
  struct ActionListNode *actionListNode;
  struct ActionNode *actionNode;
  struct StateNode *prevState;

  list = stateListNode[round];
  if (size < SIZE_THRESHOLD) {
    if (size > biggest_size)
      biggest_size = size;
    f_viter(list, MAX_ITER);
    return;
  }

  // initialization
  state_hash = (int*)malloc(size * sizeof(int));
  inv_state_hash = (int*)malloc(gNumStates * sizeof(int));
  local_id = (int*)malloc(size * sizeof(int));
  local_postI = (int*)malloc(size * sizeof(int));
  local_postR = (int*)malloc(size * sizeof(int));
  int state;

  // record all states
  int state_num, trial;
  struct StateListNode *stateListNode;
  for (state_num = 0, stateListNode = list; stateListNode; stateListNode = stateListNode->Next, ++state_num) {
    int state_id = stateListNode->Node->StateNo;
    state_hash[state_num] = state_id;
    inv_state_hash[state_id] = state_num;
  }

  // search
  trial = 0;
  while (trial < 100) {
    for (stateListNode = list; stateListNode; stateListNode = stateListNode->Next, ++trial) {
      stateNode = stateListNode->Node;
      // if it is a state connected from a state with lower topological order, then search
      for (actionListNode = stateNode->PrevAction;
           actionListNode;
           actionListNode = actionListNode->Next) {
        actionNode = actionListNode->Node;
        if (actionNode->Dominated)
          continue;
        prevState = actionNode->PrevState;
        if (id[prevState->StateNo] > id[stateNode->StateNo]) {
          search_inside_component(stateNode, round, trial);
          break;
        }
      }
    }
  }

  // build top structure
  local_cnt = 0;
  local_scnt = 0;
  for (state = 0; state < size; state++)
    local_id[state] = -1;
  for (state = 0; state < size; state++)
    if (local_id[state] == -1)
      c_dfsR(state, round);
  for (state = 0; state < size; state++) {
    local_postR[state] = local_postI[state];
  }
  
  local_cnt = 0;
  local_scnt = 0;
  for (state = 0; state < size; state++)
    local_id[state] = -1;
  for (state = size - 1; state >= 0; state--)
    if (local_id[local_postR[state]] == -1) {
      c_dfs(local_postR[state], round);
      local_scnt++;
    }

  if (local_scnt > 1) {
    // generate local node lists
    local_stateListNode = (struct StateListNode**)malloc(local_scnt * sizeof(struct StateListNode*));
    local_reachableC = (int*)malloc((unsigned)local_scnt * sizeof(int));
    local_sizes = (int*)malloc((unsigned)local_scnt * sizeof(int));

    for (local_round = 0; local_round < local_scnt; local_round++) {
      local_stateListNode[local_round] = (struct StateListNode*)malloc(sizeof(struct StateListNode));
      local_stateListNode[local_round]->Node = NULL;
      local_stateListNode[local_round]->Next = NULL;
      local_reachableC[local_round] = 0;
      local_sizes[local_round] = 0;
    }
    
    for (state_num = 0, stateListNode = list; stateListNode; stateListNode = stateListNode->Next, ++state_num) {
      local_list = local_stateListNode[local_id[state_num]];
      node = stateListNode->Node;
      // ignore unreachable and deadend states
      if (reachable[node->StateNo])
        local_reachableC[local_id[state_num]] = 1;
      ++local_sizes[local_id[state_num]];
      if (!list->Node) {
        list->Node = node;
      }
      else {
        new_list = (struct StateListNode*)malloc(sizeof(struct StateListNode));
        new_list->Node = local_list->Node;
        new_list->Next = local_list->Next;
        local_list->Node = node;
        local_list->Next = new_list;
      }
    }

    // computation
    for (local_round = 0; local_round < local_scnt; local_round++) {
      if (!local_reachableC[local_round])
        continue;
      if (local_sizes[local_round] > biggest_size)
        biggest_size = local_sizes[local_round];
      local_list = local_stateListNode[local_round];
      f_viter(local_list, MAX_ITER);
    }

    // free some used memory
    free(local_reachableC);
    free(local_sizes);
    for (local_round = 0; local_round < local_scnt; local_round++) {
      DeleteStateList(local_stateListNode[local_round]);
    }
    free(local_stateListNode);
  }

  else {
    if (size > biggest_size)
      biggest_size = size;
    f_viter(list, MAX_ITER);
  }

  // free additional memory
  free(state_hash);
  free(inv_state_hash);
  free(local_id);
  free(local_postI);
  free(local_postR);

}

void f_viter(struct StateListNode *list, int MaxIter)
{
  int                       Iter;
  double                    diff, maxdiff, /* Bellman residual */
                            error, time, threshold = 300.0;
  struct StateListNode     *stateListNode;
  
  for (Iter = 0; Iter < MaxIter; Iter++) {
    maxdiff = 0.0;
    for (stateListNode = list; stateListNode && stateListNode->Node; stateListNode = stateListNode->Next) {
      if ((stateListNode->Node->Terminal != 1) && (stateListNode->Node->Terminal != 5)) { 
	diff = BackupTwo(stateListNode->Node);
	if (diff > maxdiff)
	  maxdiff = diff;
      }
    }
    if ( gDiscount < 1.0 ) 
      error = (maxdiff * gDiscount)/(1.0 - gDiscount);
    else
      error = maxdiff;
    //printf("\n%3d ( %f secs.)  f: %f  Error bound: %f", Iter, (float)(clock()-gStartTime)/CLOCKS_PER_SEC, Start->f, error);   
    //fflush(0);
    time = (float)(clock()-gStartTime)/CLOCKS_PER_SEC;
//    if ( error < gEpsilon )
    if ( (error < gEpsilon) || (time > threshold) )
      return;
  }
}

